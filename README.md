# django-essential-training

[LinkedIn Learning Course - Django Essential Training](https://www.linkedin.com/learning/django-essential-training)

https://github.com/LinkedInLearning/django-esst-2894047

## Introduction

### What is Django?

Who doesn't want to build applications super fast with a great structure and simple framework? We also need phenomenal security and user authentication built in to make sure we have a reliable system. One of the best frameworks for doing this is Django. Django is an open source framework for building web apps quickly, and with very little code. In this course, we'll cover the essentials and we'll build a working application from start to finish. We go through a signup, login, creation and deletion of content. The whole full. I'm Leticia Portella, I'm an oceanographer that fell in love with programming and after teaching myself how to program, I've been working as a software engineer for many years. Join me in this LinkedIn learning course. As we dive into Django, and start building your first application.

### What you will need to start a Django project

There are a few things you need to get the most out of this course. You will need a Python 3.8 virtualenv and you must install Django 3.2, but should also work with later versions of Django. This is a simple stall. You'll just beep install Django and you'll get the latest version. We also need an editor, I'll use VS Code, and a browser, I'll use Chrome, but feel free to choose the tools you think are best for you. You might want to have at least some familiarity with HTTP and an idea of its methods. This will help you have a solid foundation and understand everything even better. And finally, we're going to host our exercises on GitHub, so you can check it out. If you need a refresher on any of this, check out some courses here in the library.

- Python 3.8 virtualenv

```bash
brew install python
python3 -m venv venv
python -m pip install --upgrade pip
pip install -r requirements.txt
```

- Django 3.2

```pip requirements
Django~=3.2.10
```

## 1. Starting Your Django Project

Building your Django Project

1. Start your project
2. Create your first view
3. Use templates

### Creating a new Django project - `django-admin startproject`
With Django, we can have a whole project working in a matter of minutes. We can start our project by using a Django command, called Django-admin, and then a sub-command, startproject, then, the name of our project, smartnotes, and then dot to indicate we want to create the project in this folder. Okay, so this command creates two things: a managed.py file and a folder called smartnotes, the same name we gave our project. The managed.py file will be the entry point of your project. With it, you'll be able to run your project server, manually work with the database, and much more. If you look inside the smartnotes folder, you'll notice that all of the files here are related to the configuration of your project. The two main files you'll use here are the urls.py file, where you're going to configure, well, the URLs of your project, and the settings.py. Let's take a quick look into the settings.py. You can see here that there is a lot of global variables being defined. For instance, the debug equals true here tells Django that we are working in a development environment. Because we're in this safe development environment, it can return much more information when something goes wrong than it would in a production environment. You don't really have to understand everything it has right now, we'll get to it eventually, the only thing you need to know is that this is where you have the base of your project. As magic as this sounds, you already have everything you need to run your project. You can use Python, then the file, manage.py, and the command runserver to create a server using the default configurations we have right here. We can see here that there is some warnings in red, but you don't have to worry about it for now. You can also see that we're using Django Version 3.2, and that the configuration file being used is the smartnotes.settings. This means that this server is using this settings.py inside the smartnotes folder as the basis of it. You can also see that it gives a link to a web page hosted in the port 8000 of your local host. This means that your project is up and running on your computer and you can access it by using your browser. Let's click here and see what happens. Yes, you can see here that it will open a web page with the default layout. This means that you have successfully created and ran your first Django project, congratulations.

[manage.py](./manage.py) will be your entrypoint of your Django project. With it, you'll be able to run your project server, manually work with the database, and much more.

Your generated Django project folder, in this case [smartnotes](./smartnotes/), will contain all of the files related to the configuration of your project such as settings and urls, etc.

```bash
python3 manage.py runserver
```

### Minimum working page - `django-admin startapp`

When dealing with big software projects, we need to make sure we are not creating a mess. The way we do this is to compartmentalize our project into smaller sections that have clear boundaries from day one. That's why Django created the concept of apps. Let's create one to understand it better. We'll use again the django-admin command to create a new app called home. You can see now that we have two folders: smartnotes, which is our settings folder, and home, which is the Django app we just created. Every time we create an app, we need to add it to the settings file so that it knows that that folder is part of the project we're running. Let's open the settings.py file. And add the name of our app in the INSTALLED_APPS variable. In order to make things a bit more organized, I always leave a small comment separating this app, created by us, from those that were already installed by default. Okay. Now that we have our project started, our app configured, it's time to create our first view. Let's go to the home, then go to the views file, and write our first function. As you can see, this is a pre-configured file. So we need to create our functions here. Let's import from django.http import HttpResponse. We can delete this, and now we create def home. It receives a request. And it return an HttpResponse with a simple message. Hello, world! As you can see, this function is saying that every time it receives a request, it will return a response with the text Hello, world! Okay, but how does it know when to send a request to this function? Well, that's why we have the urls.py file. We can go back now to the smartnotes, urls.py, and import this file there so we can have access to this function. So from home, let's import views, and now here inside the urlpatterns, we're going to add a new path. Let's call it home. And let's say views.home. Okay, so let's run our server again, and see what happens if we go to the localhost:8000. Yeah, so now instead of that beautiful page we had, because we have something implemented and not just the default configuration, we start to receive a 404, which makes sense because we never implemented anything here. However, because we have the debug equals true on the settings file, Django will list the endpoints that this project has available. And guess who is there. Yes, our home endpoint we just created. Now if we go to localhost home, we can see that we have the Hello, world! being displayed. Amazing, right? Let's take a moment here to understand what's happening. When a person goes to the home endpoint, they're making a request to that path. Django will go to the urls.py file to see if it's ready to receive a request at this path. Since it is, it will go to the views file, finally arriving to the function we defined. Since the function received the request, it can then respond with a message Hello, world! Django uses a common pattern as the way of structuring its project called Model View Template framework, or MVT. Views are responsible for handling requests and responses. In this video, you have learned that views can be as simple as functions, and can respond with something as simple as pure text. There are yet two additional layers for us to get familiarized with, right? These additional layers will allow us to increase our project's complexity, while being simple tools to work with. The model layer handles the data and how it's stored, and we'll see more about it in chapter three. The template layer allow us to render the information coming from the database into lovely HTML pages.

Every time we create an app, we need to add it to the settings file so that it knows that that folder is part of the project we're running. Let's open the [settings.py](./smartnotes/settings.py) file. And add the name of our app in the `INSTALLED_APPS` variable. In order to make things a bit more organized, I always leave a small comment separating this app, created by us, from those that were already installed by default. Okay. Now that we have our project started, our app configured, it's time to create our first view.

```bash
python3 manage.py runserver
```

http://127.0.0.1:8000 does not return anything since config is not setup (modified from the default config)

http://127.0.0.1:8000/home returns `Hello, World!` as expected


Django uses the Model View Template (MVT) Framework

Views are responsible for handling requests and responses.

Model Layer - handles the data and how it's stored

Template Layer - allow us to render the information coming from the database into lovely HTML pages

### Creating your first Django Template

Okay, it's time to learn how to return HTML pages by using the amazing Django template language. Let's start by creating a folder called templates inside our app folder. And inside of this folder, we'll also create another folder with the same name as our app, so let's call it home. This might seem weird, but it will allow us to quickly identify where a template is located, even if we don't know in which app we are on. This is a typical organization pattern for Django templates. Inside this folder, let's create a file called welcome.html. And inside it, we're going to add a basic HTML page. So a html tag, let's add a header with a title, so SmartNotes, and then a body with just one Welcome to SmartNotes. Okay, so now we can go back to the views file and change our base function. Instead of using the HttpResponse, we'll use the function render from the Django shortcuts that's already imported here. To use this function, we need to pass three parameters, the original request, the name of the template, and empty brackets. I know there is a warning here in the terminal that sounds a bit scary, but don't worry, this is normal, and we'll get to it later. Let's save this file and check the home end point again. And voila, our beautiful HTML is now being rendered. You might be wondering why we left the empty brackets behind, right? Although we are writing an HTML page, Django is actually using a template framework to create the final HTML page that we see in the browser. We can use the brackets at the end of the function as a way of passing down information from the view to the template. So let's import the datetime model and pass today's date into the dictionary with a key called today, datetime.today. We can then modify our template to receive a variable called today by defining it between double brackets. Today is today. Let's save it and try it again. There it is. This is why we're not using pure HTML, but actually a backend framework for defining templates called Django template language, or DTL. The HTML file we wrote will pass through the detail mechanism and it will insert the variables passed on the dictionary of the render function down to the template. This looks simple now, but DTL allows us to use sophisticated programming logic for creating dynamic HTML pages with very little effort.

```bash
python3 manage.py runserver
```

Django template language (DTL) - backend framework for defining templates
DTL allows us to use sophisticated programming logic for creating dynamic HTML pages with very little effort.

### Django apps and the concept of modularization

- [Instructor] Earlier, we talked why apps are a good way to organize our project. Let's take a minute to understand a bit more why this type of modularization is such an important concept. As you've seen, an app is a small library that is contained inside your Django project. We can have as many apps as we want, however, as the project grows, if we don't take care of it, things can start to get messy and things will fly between the apps. That's why we need to understand what we need to do to make good Django apps. Good software projects should be well modularize, and your Django project should be no different. That's why each app should be self-contained, which means that everything you need for that app should live inside it. That's why we created the folder template inside it. The ideal app is one where you can delete the folder and do nothing else, the Django project just continued to work perfectly. So far, we're almost there, but there's still one thing that we need to do to clean things up. When we created our first endpoint, we had to import the fuse file from home into the URLs file in the smart notes folder. This creates a dependency that wouldn't allow us to quickly delete the home app. Let's make things a bit more organized. Okay, so first thing is to create another URL file inside the home app. In here, we're going to create a file, very similar to the one we have on the smart notes app. And let's add the same endpoint that we had in the previous file, views.home using the home function. Okay, so now comes the fun part, in the smart notes, let's get the URLs file. We can delete the dependencies that we implemented here, and now from the jungle URLs, we're also going to import the include function. Now, what we need to do is add an import path, but instead of using a function, we're going to use the include function here to pass that file as a string. So path, let's leave it open for now, and then let's include the home.urls file. Let's save this, and if we go back to browser, yes, as you can see here, nothing changed except the fact that now, if we delete the whole app, these won't give any errors because the app is not being important on this smart notes URLs file. There, with just a couple of tweaks, we eliminated a dependency and your project is following good standards of Django applications.

Good software projects should be well modularize, and your Django project should be no different. That's why each app should be self-contained, which means that everything you need for that app should live inside it. That's why we created the folder template inside it. The ideal app is one where you can delete the folder and do nothing else, the Django project just continued to work perfectly.

## 2. Django Built-In User Management

### Creating users in Django

Even though Django is typically known for the ease in which we can create endpoints. One of the most powerful features is the Django Admin Interface. It provides an interface. So that site administrators like you and me can easily view and manipulate data. Let's check out how that works. Are you wondering what you need to get it? Nothing, the system comes by default. When you open the local host 8000, you can see that besides the home endpoint we created, the admin endpoint is also available. Let's open it. As you can see, this is a login interface, but what now we didn't create any authentication system right, wrong. Django has the entire authentication system ready to go. The only thing we need to do is to make sure our database is properly configured. Let's go back. And remember when we had this red message while running the run server, this message is letting us know that our project has some database changes that weren't applied yet. The way Django knows if the database is behind the system, changes is through a couple of files called migrations. Migrations, explain what kind of changes a database need to perform such as create a new table, establish a new relationship, et cetera. Django already has the migrations for the authentication system ready. So what you need to do is apply them to the database and we do this by using the command migrate that will actually change the database. So what we can do now is run the command migrate. Okay, you can see here that the changes made are all regarding the admin and the auth apps. We don't see these apps because they come from Django by default, but they are there and they're ready to be used. You shouldn't worry too much about migrations now. We'll learn a lot about them in future classes. Since now, our database is up to speed with Django. What we need is to create a super user that will have all the powers that can in this Django project. We do this by running the command, create super user. It's pretty straightforward. Let's make the username admin. I'm going to leave the email address empty, and I'll add admin as a password. As you can see, Django already has a couple of checks to guarantee we are creating secure passwords. You can bypass it for now as I will just because this is while we are developing this project locally, never bypass it in production environments. Security must always be your number one priority, and Django is here to help you. Okay, now we can go back to the local host 8000 admin. Well, first let's run the server again. Okay, now we can go back to the admin interface, Admin, admin, login, and there you go. Now you have full access to the Django Admin Interface. And as you can see, we don't have any red messages now, while we run the run server, because our database is completely up to speed with the project. There you go.


Migrations, explain what kind of changes a database need to perform such as create a new table, establish a new relationship, et cetera. Django already has the migrations for the authentication system ready. So what you need to do is apply them to the database and we do this by using the command migrate that will actually change the database.

```bash
python3 manage.py migrate

python3 manage.py createsuperuser

python3 manage.py runserver
```

### Django admin: Easily visualizing and creating data

The Django admin interface allow us to quickly and easily access data that exists in the database. This means that users and groups, you can see here, are actually tables in our database. If we open the users table, we can see that we already have one record, the admin user we created using the create super user command. This is the one you're logged with right now. The interface also allow us to quickly filter the data by some of the characteristics of users. We can search for a user by staff status, super user status, et cetera. You can also search by a characteristic on the search bar here. Let's create a new user, shall we? We have to go here on add user, then add a username, and let's add a password. adminadmin. Save. As you can see here, we can't bypass the password check on the interface, so we actually need a really good password here. And let's click save. Perfect. Now we have the user created. As you can see, to create a user, we just need the username and password, but there is more to it, such as personal information, permissions, et cetera. All of this complex authentication user was created by Django by default. We just need to use it. One thing that I would like you to notice is that the password is encrypted. And that's why you're seeing a bunch of random characters here. By using Django's authentication system, you're also guaranteeing that your system is correctly and safely storing passwords. If we go back to the list of users, you can see now that we have the user recreated. We can also select it and delete the selected user. As you are deleting data, Django prompts a second screen with the data you're deleting so you can confirm that you want to perform the section. So let's click Yes, I'm sure, and there, we successfully deleted that user. If we go back to the homepage, we can also see that the interface lists the actions we made in the system, such as the creation and deletion of a user. As you can see, the admin interface is a nice and safe space to directly access data in the database. If your system doesn't require inputs from users, like a blog, for instance, you can use this interface to create all the data you want and use the views to display it. It's simple and powerful.

### User authentication in two simple steps

So far, you've learned that Django comes with a powerful authentication system, already ready to be used. Now, let's learn how to use it. First, let's go back to our home app and create a second template. Let's call it "Authorized." And in here, let's create a simple HTML that has a title, You are in a restricted area. Now we can go back to the views file and create a very similar function to home. But this time we're going to display the authorized template, def authorized request. And it's going to return render request. Now let's add the home authorized dot HTML and empty square brackets. Yeah, so now we have exactly the same thing, and here comes the wonderful Django simplicity. In here, let's import from Django dot contrib dot auth dot decorators. Let's import login required. So now I can add this function as a decorator to our authorized function. That's it. That's all we need to do to block the access of this webpage if a user is not logged in. To finalize, let's go to the urls dot py and add this as a path. So let's call it authorized and views dot authorized. Now we can go back and try to access the authorized endpoint. There you go. We can see the template we created. This is only possible because we're logged in via the Django admin interface. If we go back to the admin and log out and try to re-access the authorized area, you see here that we get a 404, meaning that this page was not found. Why is that? Because we're not logged in. The complex authentication system just required a single line of code. However, a 404 is really not a nice flow, right? We want the user to know that they need to be logged in to access this page. The ideal flow is that we redirect them to the login page. To do this, we need to go back to the views file and add a parameter called login url. And let's pass this as slash admin. If we go back and try to access it again, and there it is. Since we are not logged in, Django understand that it needs to redirect me to the login url, which for now was defined as the admin end point. How amazingly simple was to add authentication to this endpoint?

## 3. How Django Interacts with Databases

### Introduction to ORMs

So far, you've gotten familiarized with the user models, which were completely defined by Django. Now it's time to understand how to create your own models and how the structure of creating models work. Django uses an object relational mapping system or ORM to handle database communication and changes. What you need is to write class models that will then be transformed by migrations into database tables. Each class known as a model is a database table and each class attribute is a column. The way we transform a model into a database table is by the creation of migrations. Migrations will have the step-by-step transformation that a database must do to apply the changes made in the code. You've seen that we use the command migrate to apply migrations to a database. Similarly we can use the command, make migrations to create migration space on the current code, the process of using a class, defining a model, creating a migration, and applying the immigration and the changes to the database is the ORM's job. And Django's ORM, is known for being one of the best ORM's for Python and SQL databases.

Django uses an object relational mapping system or ORM to handle database communication and changes. Class models can be transformed by migrations into database tables. Each class known as a model is a database table and each class attribute is a column.

### Creating your first model

It is time for us to learn how to create a new model using Django ORM. Let's create a new app specifically for our notes. So Django-admin startapp notes. Okay. Remember, now we have to go to the settings and make sure that our new app is added in the installed apps variable. Okay. Now we can go back to this new app and open the models.py file. Here is the file where we can create the models that we'll use in this app. So let's create a new class called notes that we'll inherit from models.Model. This way, Django knows that this is a model that will have effect on the database, et cetera. Its time for us to think what attributes we want in our note. Well first, we can add a title. A title is a short text, so we can use the type Charfield, which is a limited text view. Charfield has a parameter called max length, and we should set it to a value, let's say 200. This means that our title can't be over 200 characters. Okay, we also need the notes itself, right? And the notes shouldn't have a limit, so instead of using Charfield, we can use the type TextField. As you can see, TextField doesn't require a max length differently from Charfield. We also want to know when this note was created, so we can add a field called created, that is going to be a DateTimeField. Because we don't really want to worry about this field being correctly populated, we can add a parameter called auto_now_add equals to true. This means that every time a note is created, this field will be correctly populated with the time that this note was created, so we don't really have to worry about it. There. Our notes model is done. Every note we create, we'll have at least a title, a text, and a date. Amazing. So what do we need to do now? I hope you guessed it right. We need to create migrations. Luckily, this is super easy to do. Let's type python manage.py makemigrations. Let's see what happened here. There is a new folder called migrations, and inside of it, there's a new file called 001_initial. Every first migration of an app will be named like this. If you open this, you can see that this is just a list of operations that instructs the database what needs to be done. So far, we haven't changed anything in the database, we just created the set of instructions, so everything continues as it is. What we need to do now is apply the migrations so we can run python manage.py migrate. And we're done. The changes were applied to the database and we have a shiny new table.

Create migrations after modifing [models.py](./notes/models.py)
```bash
python3 manage.py makemigrations
python3 manage.py migrate
```

### Using admin for data creation and manipulation

We've already created a table for notes, but if you're curious enough to go to the Django admin interface, you'll notice that nothing really changed. Why is that? The same way we didn't have to create a user model, it was just there. We didn't have to configure it to appear on the Django interface. When we are creating a new model, we need to do it ourselves. So let's go back to the notes app and open a file called admin.py. This is where we go into add which models can be displayed, and thus, modified via the Django admin interface. First, let's create a class and call it NotesAdmin. This class should inherit from admin.ModelAdmin. Let's add pass here because we don't want any additional configuration on this admin model. Now what we need to do is import from this folder. Let's import models, and on the bottom of the file, we're going to register that that model is attached to this admin model. So let's write admin.site.register, then models.Notes, and NotesAdmin. Okay, that's it. Let's go back to the admin and refresh it. There you go. Now we can see that the notes model is available on the admin interface. Let's use the add button here to create a new note. Let's title, My First Note, and then, Django is so amazing. Let's save this. Okay, we have our first note created. One thing that isn't really nice is that it is listed as this Notes Object One. This is fine for now, but if we have a long list of notes, how can we tell which one is which? Let's go back to the admin class. Instead of pass here, we can pass list_display, which is going to be a tuple, and let's pass title here. Let's save this. It restarted. And now, if we refresh here, there, instead of having this ugly name, we have the title of the note being displayed here. The default configuration of admin also allows that all fields can be changed by all users. However, we can edit the admin model class and start adding some specialized logic. We can remove some fields from being edited. We can allow only staff users to write notes. There's a lot we can do, the sky's the limit. Django admin is highly configurable.

### Using Django shell for creating and querying data

- [Instructor] We've already learned how to do things via the Django admin, but it's time to learn how to handle models through code. Django has a tool we can use to check the content of a database, which will make our life so much easier, the Django shell. Let's go to the terminal and type python manage.py shell. You can see here that we have a Python interpreter, however, this is no ordinary interpreter, it is already tightly coupled with our project, for instance, we can type from notes.models import Notes, which is the model we just created, and with this, we can use it to query the objects in the database. Let's try to get the first note, mynote, Notes.objects.get, pk is equal to one. There, we have our note. Notes.objects is the main way of accessing data from the notes table in the database. The .get method will search for one object, which the pk private key is equal to one and returns that object. Now we can use it to access attributes of the model by simply typing mynote.title, or my note.text. We can also query for all objects in the database by using the method .all instead of the .get. Notes.objets.all, there you go, we only have one note so far. The return of this function is a query side, which is a very useful tool, but you can think of it as a list with the superpowers. We can also create a new note via the command line, let's try it out. New_note, Notes.objects.create, then title is equal to a second note, and then text is equal to this is a second note. There, the note was added to the database. If we query it again, you can see now that we have two objects being returned. If you prefer, you can open the admin interface and check it out. We can also filter notes that we want, for instance, we can query for the notes that have titles starting with the word, my. Notes.objects.filter, for the title starts with the word My, yeah. The filter also returns a query set, which in this case, returns the first object. We can also search by something that exists inside the notes, for instance, we can try to find texts that contains the word Django. So we type Notes.objects.filter, text__icontains the word Django. There you go, only the first object has the word Django in the text. We can also query for the opposite, we can actually filter notes by excluding them, so let's do the opposite notes.objects.exclude, notes that the text contains the words Django. You can see now that the filter is returning the second note instead of the first. The fun part is that query sets can also be filtered, meaning that we can add multiple filters at once, for instance, we can filter all the notes containing the word Django, but the title doesn't say anything about Django. Text contains the word Django, but exclude the ones where the title contains the word Django, there you go. As you can probably imagine, we can go on and on here with thousands of examples on how to query data. Django's ORM has a very neat interface that is very intuitive and yet highly powerful. I highly encourage you to try more queries by yourself.

```bash
(venv) victorhuerta@Victors-MacBook-Pro django-essential-training % python3 manage.py shell
Python 3.12.2 (main, Feb  6 2024, 20:19:44) [Clang 15.0.0 (clang-1500.1.0.2.5)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
(InteractiveConsole)
>>> from notes.models import Notes
>>> mynote = Notes.objects.get(pk='1')
>>> mynote.title
'My First Note'
>>> mynote.text
'Django is SO amazing!'
>>> Notes.objects.all()
<QuerySet [<Notes: Notes object (1)>]>
>>> new_note = Notes.objects.create(title="A second note", text="This is a second note")
>>> Notes.objects.all()
<QuerySet [<Notes: Notes object (1)>, <Notes: Notes object (2)>]>
>>> Notes.objects.filter(title__startswith="My")
<QuerySet [<Notes: Notes object (1)>]>
>>> Notes.objects.filter(text__icontains="Django")
<QuerySet [<Notes: Notes object (1)>]>
>>> Notes.objects.filter(text__icontains="Django").exclude(title__icontains="Django")
<QuerySet [<Notes: Notes object (1)>]>
```

## 4. Building Dynamic Webpages

### Creating a dynamic template

Now that we have our notes, how about we learn how to display them? Let's create a new view, the same way we created the other one. So notes, views.py file. And let's start with importing the models and import Notes. Okay, now let's create a function called list that receives a request, and then a variable all_notes that stores all the notes that we have in our database. Now let's return the render function again. Request, a template that we're going to create a little bit later, notes/notes_list.html, and now the brackets with notes are equal to all_notes. This is not much different from what we did in the other view, except for one thing: We are querying for all notes and sending them to the template. This way, when the template is rendered, all the information coming directly from the database will be available. Before we jump to the template, let's organize URLs. So let's create a new urls file here. And that's going to have the same format. So from django.urls import path. Then let's import the views here. And then the urlpatterns that has a list. Then here the path. Our endpoint's going to call notes because that's the list of notes. Then views.list, which is the function we just created. Amazing. The last thing is that we have to add this on the urls.py file on smartnotes. So let's add a comma here. Then path. Let's add smart here and then include notes.urls. Amazing. By doing this, all the URLs that we are adding on notes.urls will be added after the smart. So smart is going to be a part of that endpoint. This is a really nice way of organizing our project. Okay, almost there. Now we need to create the template folder. So notes, New Folder, templates. Then a new folder, notes. And now we can add our template. Notes_list.html. Okay, now we can create our template. So let's start by html. In h1, these are the notes. And now we'll start to use the powers of DTL. Bear with me just a little bit. So let's start with ul, and then curly brackets, two percentages, and in the middle, for note in notes. Okay, so in here, we're going to add a line item, two curly brackets, note-title, close the curly brackets, and now we need to do curly brackets, percentage, percentage, and in the middle, it's going to have an endfor. Okay, what's happening here? Everything that is between curly brackets is the Django template language logic. Here we're opening a list tag ul, and then saying that for each note we receive in the template, DTL should create a list item, the li. Notice that commands, such as the loop happen between curly brackets and percentages, while things that should be rendered by the template are between double brackets. So let's save this. Then run this runserver. And open it. Okay. Okay, now we can see that we have a smart here. Then let's try the smart. We're going to have the notes. And here are the notes. There it is. A web page that is dynamically getting data from the database and adding it to the HTML. If we right click here and inspect the page, we'll see here that we actually have two line items. That's because we have only two notes on the database. If we had many more, many more would be created. How easy was that? I encourage you now to go and create more notes, either via the shell or the admin and see what happens here.

### Display content of a single note

Now that we have a list of notes, how about we create a way to visualize details of a particular note? Let's go back to the notes app, views.py and let's create a new function here. Now, this function should receive a second parameter called pk for private key. So let's go def detail request, pk. Okay, now we can use this pk to go in the database and get that particular note. So note is equal to Notes.objects.get. Pk is equal to pk. Okay, and the common response. Return render the request. Let's keep the pattern here. So notes/notes_detail.html. And then let's pass note inside the brackets. Okay, now what we need to do is create the template. So let's go back here. New file, notes_detail.html. And let's create a simple HTML that has the title as note.title is an h1. And then let's go a text here, note.text. And there you go. Okay, so there's one thing still missing, which is the URL. This needs to be a slightly different URL because we need to be able to pass down the second parameter to that function. So let's do this by adding a new path here. So we're going to have notes, then slash, the minor and greater sign, and pk. Great, and now the views.detail. Okay, so what we're telling here is that URL will receive a new value named pk that will be an integer number. Now, the only thing left to do is start the runserver again. And test this out. So here we have the notes, and if we pass now the pk for our first note, we can see the template displaying the details of the first note. Okay, so this works fine but we still have a problem. The get method that we're using to get the note from the database will actually throw an error if you pass down a private key that doesn't exist. So if we try the same URL but with I don't know, 11 or something, unless you have created 11 notes, this will raise an error. So let's try it out. Notice here that this is returning an exception of the type does not exist. We can also see here that there is a message with the exception saying notes matching query does not exist. Django has an amazing traceback for us to understand where exactly the error happened. You can see right here that the problem started in line 11 on the notes, views.py file, which is exactly where we define the query. We only have this page explaining the error again because we continue to have the debug equals true in the settings file. In a production environment, the user would see a 500 error, which means an internal error. When an object is not found, the correct response is a 404 status code saying that that object does not exist. So let's change our code to make sure that we get the correct status code. Let's go back to the views file. And in here, let's import from django.http. Let's import Http404. Okay, and now we can wrap this query in a try and except block. So try and except if the Notes.DoesNotExist equals true, we're going to raise an Http404 with the message Note doesn't exist. Okay, so if you go back now to the previous link, and refresh, we're going to see here that this page is now returning a 404 with a message that we define. This is a much nicer flow than the error we had before because we're controlling the message to the user. If you can, we can actually create another template, specifically for a 404 and return it with a nice message. It is completely up to you.

### Introduction to Django class-based views

So far, you've learned how to create views using functions. However, Django has a couple more features that we can leverage to get things even simpler. Welcome to class-based views. Most views have similar patterns, and reinventing the wheel is something nobody really wants. Class-based views are extensive classes that implement typical view behavior, and you just need to override a few things to make it do what you want. This will allow us to avoid the boring work and focus on the things that are unique to our project. Let's go back to our code and change our views that are function-based to the ones that are class-based and see in detail how class-based views work. The first view we made was in the home app, so let's go back and change it. The only thing we need to do here is display a template, so we can do that by using the class-based view TemplateView class. So let's in here import from django.views.generic import TemplateView. Okay, so now we can create a new class called HomeView that inherits from TemplateView, and the only thing we need to pass here is the template name. So we can copy here and paste it here, and that's it. We still need one more thing because our template requires some extra information, so we can add a variable called extra_context and now pass this dictionary here in it. We can delete this now. Oops, it's missing something, okay. So now we can delete this function here, and we have our first class-based views. The last thing missing is that we need to change the way the URLs are defined, so let's go to the URLs, and in here, instead of passing the home function, we're going to pass the HomeView class and we need to call a method called as_view. You can see here now that the server is working just fine, so we can go back here, and it's still working. So we can quickly do the same with the second function here, the authorized view. So let's create a class called AuthorizedView that also inherits from TemplateView. Then the template_name. We're going to have this here. Oops, there's an extra space here, okay. Okay, because we don't have the extra attributes required here, we can just not pass the extra_content. Okay, but we're still missing authentication. How do we handle authentication on class-based views? Well, to do that, we're going to need a mixin class. *Mixins are helper classes that can be used along with other classes to provide additional features.* For this case, we'll use the LoginRequiredMixin. So let's go back here, and we can remove this now and use the from django.contrib.auth.mixins. We can import LoginRequiredMixin. The only thing we need to do here now is make sure that this class, which is a mixin, is added before the TemplateView, okay? The last thing missing is the login_url. So we can actually go here, add the login_url. Let's still pass the admin, and that's it. So we can remove this now, fix the URLs to be AuthorizedView.as_view, and that's it. As you can see here, things are quite nice and well-organized, and you also don't have to remember the requests coming in and out of the function. Class-based views might not seem like the amazing features they are, but that's because we are still handling simple views. As the views increase in complexity, they become more and more amazing allies.

